{"ast":null,"code":"var _jsxFileName = \"/Users/lijiajia/Desktop/hooks/hooks/src/extra/useCallback.js\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useRef, useCallback } from 'react'; //每次setCount 之后，都会重新渲染一次dom,那么就会每次都创建一个add函数\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst s = new Set();\nexport const useCallbackExample = () => {\n  _s();\n\n  const [count, setCount] = useState(0);\n\n  function add() {\n    setCount(count => count + 1);\n  }\n\n  s.add(add);\n  console.log(s.size); //通过s.size可以看出来，每次都增加2\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [count, /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: add,\n      children: \"\\u70B9\\u6211\\u589E\\u52A0\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 16,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 14,\n    columnNumber: 9\n  }, this);\n}; // //用useCallback优化后的代码\n// const sOpt = new Set();\n// export const  useCallbackExampleOpt=()=> {\n//     const [count, setCount] = useState(0)\n//     const add = useCallback(\n//         () => {\n//              setCount(count => count + 1)\n//         },\n//         [],\n//     )\n//     sOpt.add(add);\n//     console.log(sOpt.size)//只有两个？\n//     return (\n//         <div>\n//             {count}\n//             <button onClick={add}>点我增加</button>\n//         </div>\n//     )\n// }\n//weakSet 和set 垃圾回收机制 区别？？？\n\n_s(useCallbackExample, \"oDgYfYHkD9Wkv4hrAPCkI/ev3YU=\");","map":{"version":3,"sources":["/Users/lijiajia/Desktop/hooks/hooks/src/extra/useCallback.js"],"names":["React","useState","useRef","useCallback","s","Set","useCallbackExample","count","setCount","add","console","log","size"],"mappings":";;;AAAA,OAAOA,KAAP,IAAgBC,QAAhB,EAA0BC,MAA1B,EAAkCC,WAAlC,QAAoD,OAApD,C,CAGA;;;AACA,MAAMC,CAAC,GAAG,IAAIC,GAAJ,EAAV;AACA,OAAO,MAAMC,kBAAkB,GAAC,MAAK;AAAA;;AACjC,QAAM,CAACC,KAAD,EAAQC,QAAR,IAAoBP,QAAQ,CAAC,CAAD,CAAlC;;AACA,WAASQ,GAAT,GAAe;AACXD,IAAAA,QAAQ,CAACD,KAAK,IAAIA,KAAK,GAAG,CAAlB,CAAR;AACH;;AACDH,EAAAA,CAAC,CAACK,GAAF,CAAMA,GAAN;AACAC,EAAAA,OAAO,CAACC,GAAR,CAAYP,CAAC,CAACQ,IAAd,EANiC,CAMd;;AACnB,sBACI;AAAA,eACKL,KADL,eAEI;AAAQ,MAAA,OAAO,EAAEE,GAAjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAFJ;AAAA;AAAA;AAAA;AAAA;AAAA,UADJ;AAMH,CAbM,C,CAgBP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;GArCaH,kB","sourcesContent":["import React, { useState, useRef ,useCallback} from 'react'\n\n\n//每次setCount 之后，都会重新渲染一次dom,那么就会每次都创建一个add函数\nconst s = new Set();\nexport const useCallbackExample=() =>{\n    const [count, setCount] = useState(0)\n    function add() {\n        setCount(count => count + 1)\n    }\n    s.add(add);\n    console.log(s.size)//通过s.size可以看出来，每次都增加2\n    return (\n        <div>\n            {count}\n            <button onClick={add}>点我增加</button>\n        </div>\n    )\n}\n\n\n// //用useCallback优化后的代码\n// const sOpt = new Set();\n// export const  useCallbackExampleOpt=()=> {\n//     const [count, setCount] = useState(0)\n//     const add = useCallback(\n//         () => {\n//              setCount(count => count + 1)\n//         },\n//         [],\n//     )\n//     sOpt.add(add);\n//     console.log(sOpt.size)//只有两个？\n//     return (\n//         <div>\n//             {count}\n//             <button onClick={add}>点我增加</button>\n//         </div>\n//     )\n// }\n\n\n//weakSet 和set 垃圾回收机制 区别？？？\n"]},"metadata":{},"sourceType":"module"}